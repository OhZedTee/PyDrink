#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.19
#  in conjunction with Tcl version 8.6
#    Jan 11, 2019 12:32:59 PM EST  platform: Windows NT

import sys, os
from src.Fridge import Fridge
from src.Alcoholic import Alcoholic
from src.Glass import Glass
from src.Inventory import Inventory
from src.Translate import Translator
from pygame import mixer
from pygame import time
import traceback

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

class PyDrinkController:

    def __init__(self):
        self._fridge = Fridge()
        self._glass = Glass()
        self._inventory = Inventory()
        self._translator = Translator()

    @property
    def fridge(self):
        return self._fridge

    @fridge.setter
    def fridge(self, value):
        self._fridge = value

    @property
    def glass(self):
        return self._glass

    @glass.setter
    def glass(self, value):
        self._glass = value

    @property
    def inventory(self):
        return self._inventory

    @inventory.setter
    def inventory(self, value):
        self._inventory = value

    @property
    def translator(self):
        return self._translator

    @translator.setter
    def translator(self, value):
        self._translator = value

    #Pre: text to search must be a valid string to search. prev, next, inventory_list, textbox_selected, success_message,
    #     page_message must all be valid view objects used to display to screen
    #Post: Searched text is queried from API and returned Drinks are outputted to screen
    def search(self, text, prev, next, inventory_list, textbox_selected, success_message, page_message):
        print('PyDrink_support.search: %s' % text)
        if text == "":
            text = None

        self.inventory.page = 1
        self.inventory.search_params = text

        self.inventory.get_products(text)
        PyDrinkController.insert_manager_tree(inventory_list, textbox_selected, self.inventory, "Added To Cart",
                                              success_message)

        if self.inventory.page == 1:
            prev.configure(state=tk.DISABLED)
        else:
            prev.configure(state=tk.NORMAL)

        if self.inventory.final_page:
            next.configure(state=tk.DISABLED)
        else:
            next.configure(state=tk.NORMAL)

        text = "Page %g of %g" % (self.inventory.page, self.inventory.num_pages)
        page_message.configure(text=text)

        sys.stdout.flush()

    #Pre: inventory_list, success_message, page_message, selection_message must be valid view objects
    #     used to display to screen
    #Post: Selected drinks are added to the fridge
    def btn_add_fridge_lclick(self, inventory_list, success_message, page_message, selection_message):
        print('PyDrink_support.btn_add_fridge_lclick')
        """Event triggered when add to fridge button is pressed
            1. Adds selected drinks to the fridge tab"""
        try:
            count = 0
            for child in inventory_list.get_children():
                if inventory_list.item(child, "values")[0] == selection_message:
                    if not self.fridge.find_drink('name', inventory_list.item(child, "text")):
                        count += 1
                        d = self.inventory.find_drink('name', inventory_list.item(child, "text"))
                        d.selected = False
                        inventory_list.item(child, values=('',''))
                        self.fridge.add_drink(d)
                        self.fridge.save()
                    else:
                        inventory_list.item(child, values=('', ''))

            if count > 0:
                success_message.configure(state=tk.NORMAL)

            text = "Page %g of %g" % (self.inventory.page, self.inventory.num_pages)
            page_message.configure(text=text)

        except IndexError:
            print("No Drinks Selected")

        sys.stdout.flush()

    #Pre: tree, description must be valid view objects used to display to screen
    #Post: Selected Drinks are removed from the fridge
    def btn_remove_fridge_lclick(self, tree, description):
        print('PyDrink_support.btn_remove_fridge_lclick')
        """Event triggered when remove from fridge button is pressed
                1. Remove selected drinks to the fridge tab"""
        try:
            item = tree.selection()[0]
            drink = self.fridge.find_drink('name', tree.item(item, "text"))
        except IndexError:
            drink = None

        if drink is not None:
            tree.delete(item)
            self.fridge.remove_drink(drink.id)
            description.delete('1.0', tk.END)
            self.fridge.save()

        sys.stdout.flush()

    # Pre: prev, next, inventory_list, textbox_selected, success_message, page_message must be valid view objects
    #      used to display to screen
    # Post: API queried for previous page and displays to inventory page.
    def btn_inv_prev_lclick(self, prev, next, inventory_list, textbox_selected, success_message, page_message):
        print('PyDrink_support.btn_inv_prev_lclick')

        """Event triggered when prev button is pressed
        1. Empties the Inventory TreeView in Inventory tab
        2. Repopulates it with previous page"""
        for child in inventory_list.get_children():
            inventory_list.delete(child)

        self.inventory.page -= 1
        next.configure(state=tk.NORMAL)

        self.inventory.get_products(self.inventory.search_params)
        PyDrinkController.insert_manager_tree(inventory_list, textbox_selected, self.inventory, "Added To Cart",
                                              success_message)

        if self.inventory.page == 1:
            prev.configure(state=tk.DISABLED)

        text = "Page %g of %g" % (self.inventory.page, self.inventory.num_pages)
        page_message.configure(text=text)

        sys.stdout.flush()

    # Pre: prev, next, inventory_list, textbox_selected, success_message, page_message must be valid view objects
    #      used to display to screen
    # Post: API queried for next page and displays to inventory page.
    def btn_inv_next_lclick(self, prev, next, inventory_list, textbox_selected, success_message, page_message):
        print('PyDrink_support.btn_inv_next_lclick')

        """Event triggered when prev button is pressed
        1. Empties the Inventory TreeView in Inventory tab
        2. Repopulates it with previous page"""
        for child in inventory_list.get_children():
            inventory_list.delete(child)

        self.inventory.page += 1
        prev.configure(state=tk.NORMAL)

        self.inventory.get_products(self.inventory.search_params)
        PyDrinkController.insert_manager_tree(inventory_list, textbox_selected, self.inventory, "Added To Cart",
                                              success_message)

        if self.inventory.final_page:
            next.configure(state=tk.DISABLED)

        text = "Page %g of %g" % (self.inventory.page, self.inventory.num_pages)
        page_message.configure(text=text)

        sys.stdout.flush()

    # Pre: p1 is a valid event object, tree, textbox_selected, success_message, page_message must be valid view objects
    #      used to display to screen
    # Post: Inventory page is opened and API data is loaded to the screen
    def ntb_open_inventory(self, p1, tree, textbox_selected, success_message, page_message):
        print('PyDrink_support.ntb_open_inventory')
        print('p1 = {0}'.format(p1))

        """Event triggered when the inventory tab is opened
            Call method to add drinks from the API to the TreeView"""

        PyDrinkController.insert_manager_tree(tree, textbox_selected,  self.inventory, "Added To Cart",
                                              success_message)
        text = "Page %g of %g" % (self.inventory.page, self.inventory.num_pages)
        page_message.configure(text=text)
        sys.stdout.flush()

    # Pre: p1 is a valid event object, tree, textbox_selected, success_message must be valid view objects
    #      used to display to screen
    # Post: Fridge page is opened and Fridge Drink data is loaded to the screen
    def ntb_open_fridge(self, p1, tree, textbox_selected, success_message):
        print('PyDrink_support.ntb_open_fridge')
        print('p1 = {0}'.format(p1))

        """Event triggered when the fridge tab is opened
        Call method to add drinks from the fridge to the TreeView"""

        success_message.configure(state=tk.DISABLED)
        PyDrinkController.insert_manager_tree(tree, textbox_selected, self.fridge, "Added To Glass", success_message)

        sys.stdout.flush()

    # Pre: p1 is a valid event object, tree, cocktail_tree, textbox_selected, fridge_list, selection_message,
    #      translation_box must be valid view objects used to display to screen
    # Post: Glass page is opened and Fridge + Cocktail dictionary objects are loaded to the screen
    def ntb_open_glass(self, p1, tree, cocktail_tree, textbox_selected, fridge_list, selection_message, translation_box):
        print('PyDrink_support.ntb_open_glass')
        print('p1 = {0}'.format(p1))

        """Event triggered when the Glass tab is opened
            Call method to add drinks from the glass object to the TreeView,
            Call method to add cocktails to the TreeView"""

        cocktail_categories = {}
        alcoholic = []
        non_alcoholic = []

        try:
            for child in tree.get_children():
                tree.delete(child)

            """Iterate through all items in TreeView adding all to dict obj"""
            self.glass.clear_drinks()

            for child in fridge_list.get_children():
                if fridge_list.item(child, "values")[0] == selection_message:
                    tree.insert('', 'end', text=fridge_list.item(child, "text"),
                                values=fridge_list.item(child, "values"))

            for child in tree.get_children():
                drink = self.fridge.find_drink('name', tree.item(child, "text"))
                if not self.glass.has_drink(drink.id):
                    self.glass.add_drink(drink)
                if isinstance(drink, Alcoholic):
                    alcoholic.append(drink.category)
                else:
                    non_alcoholic.append(drink.desc)

            cocktail_categories["Alcoholic"] = alcoholic
            cocktail_categories["NonAlcoholic"] = non_alcoholic
            PyDrinkController.insert_cocktail_tree(cocktail_tree, self.glass, cocktail_categories, textbox_selected,
                                                   translation_box)


        except IndexError:
            print("Drinks and Cocktails not added to Glass Tab properly. Please try again")

        translation_box.configure(values=list(self.translator.languages.keys()))
        translation_box.current(0)
        sys.stdout.flush()

    #Pre: TKinter window must have been created and passed to Controller from the view.
    #Post: Controller is initialized
    @staticmethod
    def init(top, gui, *args, **kwargs):
        global w, top_level, root
        w = gui
        top_level = top
        root = top

    #Pre: None
    #Post: GUI window is destroyed
    @staticmethod
    def destroy_window():
        # Function which closes the window.
        global top_level
        top_level.destroy()
        top_level = None

    # Pre: Manager child obj must be valid Manager Class object, tree, textbox_selected, selection_message,
    #      success_message must be valid view objects used to display to screen
    # Post: Dictionary of Drinks from Manager child class is displayed in ScrolledTreeView and events for
    #       selection are created for each item in the ScrolledTreeView.
    @staticmethod
    def insert_manager_tree(tree, textbox_selected, obj, selection_message, success_message=None):
        """Insertion method."""
        # Clears TreeView
        for child in tree.get_children():
            tree.delete(child)

        for drink in obj.drinks.values():
            selected = ('', '')
            if drink.selected:
                selected = (selection_message, '')

            tree.insert('', 'end', text=str(drink.name), values=selected)
            tree.bind("<ButtonRelease-3>", lambda e: PyDrinkController.stv_list_selected_rclick(e, tree, obj,
                                                                                                selection_message,
                                                                                                success_message))
            tree.bind("<ButtonRelease-1>", lambda e: PyDrinkController.stv_select_lclick(e, tree, obj,
                                                                                         textbox_selected))

    # Pre: Manager child obj must be a valid Manager Class object, tree, textbox_selected, combobox_language
    #      must be valid view objects used to display to screen
    # Post: Dictionary of Cocktails from Cocktail class is displayed in ScrolledTreeView and events for selection
    #       are created for each item in the ScrolledTreeView.
    @staticmethod
    def insert_cocktail_tree(tree, obj, categories, textbox_selected, combobox_language):
        """Insertion method."""
        # Clears TreeView
        for child in tree.get_children():
            tree.delete(child)

        for cocktail in obj.find_cocktails(categories):
            tree.insert('', 'end', text=str(cocktail.name),
                        values='No')
            tree.bind("<ButtonRelease-1>", lambda e: PyDrinkController.stv_cocktail_selected(e, tree, obj,
                                                                                             textbox_selected,
                                                                                             combobox_language))

    # Pre: p1 is a valid event object, Drink obj must be a valid drink object, tree, textbox_selected
    #      must be valid view objects used to display to screen
    # Post: Event triggered from ScrolledTreeView Drink selection caused selected object to be printed on the GUI
    @staticmethod
    def stv_select_lclick(p1, tree, obj, textbox_selected):
        """Update Description of selected frame"""
        print('PyDrink_support.stv_list_selected_lclick')
        print('p1 = {0}'.format(p1))

        try:
            item = tree.selection()[0]
            drink = obj.find_drink('name', tree.item(item, "text"))
        except IndexError:
            drink = None

        if drink is not None:
            # 1 - line 0 - coloumn
            textbox_selected.delete('1.0', tk.END)
            textbox_selected.insert('1.0', str(drink))

    # Pre: p1 is a valid event object, Cocktail obj must be a valid Cocktail object, tree, textbox_selected,
    #      combobox_language must be valid view objects used to display to screen
    # Post: Event triggered from ScrolledTreeView Cocktail selection caused selected object to be printed on the GUI
    @staticmethod
    def stv_cocktail_selected(p1, tree, obj, textbox_selected, combobox_language):
        """Update Description of selected frame"""
        print('PyDrink_support.stv_cocktail_selected')
        print('p1 = {0}'.format(p1))
        try:
            item = tree.selection()[0]
            cocktail = obj.get_cocktail(tree.item(item, "text"))
        except IndexError:
            cocktail = None

        if cocktail is not None:
            # 1 - line 0 - coloumn
            textbox_selected.delete('1.0', tk.END)
            textbox_selected.insert('1.0', str(cocktail))
            combobox_language.current(0)

    # Pre: p1 is a valid event object, Drink obj must be a valid Drink object, tree, selection_message,
    #      success_message must be valid view objects used to display to screen
    # Post: Event triggered from ScrolledTreeView Drink selection caused selected object to be
    #       "Added to Cart"/"Added To Glass" (selection_message)
    @staticmethod
    def stv_list_selected_rclick(p1, tree, obj, selection_message, success_message):
        """Update Selection of drink in fridge/Inventory"""
        print('PyDrink_support.stv_list_selected_rclick')
        print('p1 = {0}'.format(p1))
        sys.stdout.flush()
        try:
            item = tree.selection()[0]
            drink = obj.find_drink('name', tree.item(item, "text"))

            # Flip sign of selected
            if tree.item(item, "values")[0] == '':
                tree.item(item, values=(selection_message, ""))
                drink.selected = True
                if selection_message == "Added To Glass":
                    success_message.configure(text="Added Selected Drink To Glass", state=tk.NORMAL, foreground="#04B431")
            else:
                tree.item(item, values=('', ''))
                drink.selected = False

                if selection_message == "Added To Glass":
                    success_message.configure(text="Removed Selected Drink From Glass", state=tk.NORMAL,
                                              foreground="#AE3A3A")

            if selection_message != "Added To Glass":
                    success_message.configure(state=tk.DISABLED)

            if type(obj) is Fridge:
                obj.save()
        except IndexError:
            print("No Drinks Selected")

        sys.stdout.flush()

    # Pre: p1 is a valid event object, textbox_cocktail, combobox_language must be valid view objects
    #      used to display to screen
    # Post: Cocktail textbox text is translated to combobox_language and displayed in GUI
    def translate_text(self, p1, textbox_cocktail, combobox_language):
        """Translate Cocktail Recipe"""
        print('PyDrink_support.translate_text')
        print('p1 = {0}'.format(p1))

        try:
            if textbox_cocktail.get("1.0", tk.END) != "\n":
                translated_text = self.translator.translate(self.translator.languages[combobox_language.get()],
                                                            textbox_cocktail.get("1.0", tk.END))

                with open(1, 'w', encoding='utf-8', closefd=False) as stdout:
                    print("TRANSLATED TEXT: %s" % translated_text, file=stdout)
                textbox_cocktail.delete('1.0', tk.END)
                textbox_cocktail.insert('1.0', str(translated_text))
            else:
                print("Nothing to translate")
        except BaseException:
            print("Unable to translate, please try again.")
            combobox_language.current(0)
            self.translate_text(p1, textbox_cocktail, combobox_language)

        sys.stdout.flush()

    # Pre: textbox_cocktail, combobox_language must be valid view objects
    #      used to display to screen
    # Post: Event triggered when button clicked, Cocktail description is converted to speech in the
    #       combobox_language and played on the GUI
    def btn_translation_sound_lclick(self, textbox_cocktail, combobox_language):
        """Play text to speech of cocktail recipe"""
        print('PyDrink_support.btn_translation_sound_lclick')

        try:
            if textbox_cocktail.get("1.0", tk.END) != "\n":
                self.translator.text_to_speech(self.translator.languages[combobox_language.get()],
                                               textbox_cocktail.get("1.0", tk.END))

                filename = "data/audio/speech%s.wav" % (self.translator.speech_num - 1)
                mixer.init(frequency=16000, size=-16, channels=1, buffer=1024)
                mixer.music.load(filename)
                mixer.music.play(0)
                while mixer.music.get_busy():
                    time.Clock().tick(10)
                mixer.stop()
                mixer.quit()
            else:
                print("Nothing to convert to speech")
        except BaseException: #Pygame.error (throws general exception)
            print("Unable to perform text to speech, language unavailable.")

        sys.stdout.flush()

if __name__ == '__main__':
    import PyDrink
    PyDrink.vp_start_gui()




